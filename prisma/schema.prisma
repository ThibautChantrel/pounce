// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

enum PoiType {
  METRO
  MONUMENT
  PARK
  RESTAURANT
  VIEWPOINT
  OTHER
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

// --- MODELS ---

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          Role      @default(USER)

  // Auth Relations
  accounts Account[]
  sessions Session[]

  // File Relations
  files File[]

  createdChallenges Challenge[] @relation("CreatedChallenges")
  updatedChallenges Challenge[] @relation("UpdatedChallenges")

  createdTracks Track[] @relation("CreatedTracks")
  updatedTracks Track[] @relation("UpdatedTracks")

  createdPois Poi[] @relation("CreatedPois")
  updatedPois Poi[] @relation("UpdatedPois")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}

model File {
  id String @id @default(cuid())

  filename String
  mimeType String
  size     Int
  data     Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById String
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)

  challengeCovers  Challenge[] @relation("ChallengeCover")
  challengeBanners Challenge[] @relation("ChallengeBanner")

  trackCovers  Track[] @relation("TrackCover")
  trackBanners Track[] @relation("TrackBanner")
  trackGpxs    Track[] @relation("TrackGpx")

  @@map("files")
}

model Challenge {
  id          String     @id @default(cuid())
  title       String
  description String?    @db.Text
  visible     Boolean    @default(false)
  location    String
  difficulty  Difficulty @default(MEDIUM)

  // Relations Images
  coverId  String?
  cover    File?   @relation("ChallengeCover", fields: [coverId], references: [id])
  bannerId String?
  banner   File?   @relation("ChallengeBanner", fields: [bannerId], references: [id])

  // Relation N-N Explicite (avec ordre)
  tracks ChallengeTrack[]

  // Audit
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  createdBy   User?    @relation("CreatedChallenges", fields: [createdById], references: [id])
  updatedById String?
  updatedBy   User?    @relation("UpdatedChallenges", fields: [updatedById], references: [id])

  @@map("challenges")
}

// Table de pivot Challenge <-> Track (Pour gérer l'ordre)
model ChallengeTrack {
  id String @id @default(cuid())

  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  trackId String
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  order Int @default(0)

  @@unique([challengeId, trackId])
  @@map("challenge_tracks")
}

// --- TRACK MODULE ---

model Track {
  id            String  @id @default(cuid())
  title         String
  description   String? @db.Text
  visible       Boolean @default(false)
  distance      Float
  elevationGain Int     @default(0)

  // Relation N-N vers Challenge (via Pivot)
  challenges ChallengeTrack[]

  // Relation N-N vers Poi (Implicite, sans ordre spécifique stocké)
  pois Poi[]

  // Relations Fichiers
  coverId   String?
  cover     File?   @relation("TrackCover", fields: [coverId], references: [id])
  bannerId  String?
  banner    File?   @relation("TrackBanner", fields: [bannerId], references: [id])
  gpxFileId String?
  gpxFile   File?   @relation("TrackGpx", fields: [gpxFileId], references: [id])

  // Audit
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  createdBy   User?    @relation("CreatedTracks", fields: [createdById], references: [id])
  updatedById String?
  updatedBy   User?    @relation("UpdatedTracks", fields: [updatedById], references: [id])

  @@map("tracks")
}

// --- POI MODULE ---

model Poi {
  id          String  @id @default(cuid())
  name        String
  description String? @db.Text
  type        PoiType
  latitude    Float
  longitude   Float

  // Relation N-N vers Track (Implicite)
  tracks Track[]

  // Audit
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  createdBy   User?    @relation("CreatedPois", fields: [createdById], references: [id])
  updatedById String?
  updatedBy   User?    @relation("UpdatedPois", fields: [updatedById], references: [id])

  @@map("pois")
}
